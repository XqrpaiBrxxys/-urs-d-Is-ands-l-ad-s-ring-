if game.PlaceId == 990566015 then
local OrionLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/XqrpaiBrxxys/-ainel-C-ursed-Is-ands-/refs/heads/main/%26aine%23"))()
local Window = OrionLib:MakeWindow({Name = "SyniX HUB - CURSED ISLANDS ", HidePremium = false, SaveConfig = true, ConfigFolder = "Synix"})




  local ABOUTTab = Window:MakeTab({
    Name = "ABOUT",
    Icon = "rbxassetid://14824506141",
    PremiumOnly = false
})

ABOUTTab:AddLabel("                                      CURSED ISLANDS")

 local Section = ABOUTTab:AddSection({
	Name = ""
})
 
ABOUTTab:AddLabel("                      Hello, thank you for using 'SyniX HUB'")
local Section = ABOUTTab:AddSection({
	Name = ""
})
ABOUTTab:AddLabel("                                  SOCIAL NETWORK")

 
 
ABOUTTab:AddButton({
    Name = "ㅤ   ㅤㅤ   ㅤㅤ   ㅤㅤ      ㅤ       ㅤDISCORD ",
    Callback = function()
        setclipboard("https://discord.com/invite/Hembr363")
        OrionLib:MakeNotification({
            Name = "SyniX HUB",
            Content = "Copied Discord link",
            Image = "rbxassetid://14962192917",
            Time = 5
        })
    end
})
 local Section = ABOUTTab:AddSection({
	Name = ""
})
  ABOUTTab:AddLabel("                     DEVELOPERS: RayzMods | Zor_Son")

-- Cria a aba e o toggle no OrionLib
local PlayerTab = Window:MakeTab({
    Name = "FARM",
    Icon = "rbxassetid://18996452012", -- Substitua pelo ID correto do ícone
    PremiumOnly = false
})

PlayerTab:AddLabel("                                                    FARM")




                                                  

                   
local toggleActive = false -- Variável para armazenar o estado do toggle

-- Função para "congelar" o personagem
local function freezeCharacter(humanoidRootPart, humanoid, targetPosition)
    humanoidRootPart.CFrame = CFrame.new(targetPosition)
    humanoid.PlatformStand = true -- Desativa a física do personagem

    local bodyPosition = Instance.new("BodyPosition")
    bodyPosition.Parent = humanoidRootPart
    bodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge) -- Garante que a força máxima seja aplicada
    bodyPosition.D = 1000 -- Damping para suavizar o movimento, se necessário
    bodyPosition.P = 10000 -- Força de posicionamento
    bodyPosition.Position = targetPosition
end

-- Configuração do Toggle
PlayerTab:AddToggle({
    Name = "WIN",
    Default = false,
    Callback = function(value)
        toggleActive = value
        local player = game.Players.LocalPlayer
        local targetPosition = CFrame.new(9972.58203125, 10053.0068359375, 20.453182220458984)

        local function freezeCharacter(character, targetPosition)
            if not targetPosition then
                warn("targetPosition é nil.")
                return
            end
            
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
            
            -- Teleporte instantâneo
            humanoidRootPart.CFrame = targetPosition
            
            -- Configurar BodyPosition para manter a posição
            local bodyPosition = humanoidRootPart:FindFirstChildOfClass("BodyPosition")
            if not bodyPosition then
                bodyPosition = Instance.new("BodyPosition")
                bodyPosition.Name = "BodyPosition"
                bodyPosition.Parent = humanoidRootPart
            end
            bodyPosition.Position = targetPosition.Position
            bodyPosition.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            bodyPosition.D = 1000 -- Alta taxa de amortecimento para manter a posição
            bodyPosition.P = 10000 -- Alta força para manter a posição
            
            -- Configurar BodyGyro para manter a orientação
            local bodyGyro = humanoidRootPart:FindFirstChildOfClass("BodyGyro")
            if not bodyGyro then
                bodyGyro = Instance.new("BodyGyro")
                bodyGyro.Name = "BodyGyro"
                bodyGyro.Parent = humanoidRootPart
            end
            bodyGyro.CFrame = targetPosition
            bodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
            bodyGyro.P = 3000 -- Alta força para manter a orientação
            bodyGyro.D = 1000 -- Alta taxa de amortecimento para manter a orientação
        end

        local function onCharacterAdded(character)
            local humanoid = character:WaitForChild("Humanoid")
            
            humanoid.Died:Connect(function()
                if toggleActive then
                    -- Reposicionar o personagem após a morte
                    local respawnCharacter = player.CharacterAdded:Wait()
                    freezeCharacter(respawnCharacter, targetPosition)
                end
            end)
            
            if toggleActive then
                freezeCharacter(character, targetPosition)
            end
        end

        -- Conectar à morte e renascimento do personagem
        if toggleActive then
            local character = player.Character or player.CharacterAdded:Wait()
            onCharacterAdded(character)
            player.CharacterAdded:Connect(onCharacterAdded)
        else
            -- Desativar a funcionalidade de teleporte e remover BodyPosition e BodyGyro se existirem
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
            
            local bodyPosition = humanoidRootPart:FindFirstChildOfClass("BodyPosition")
            if bodyPosition then
                bodyPosition:Destroy()
            end
            
            local bodyGyro = humanoidRootPart:FindFirstChildOfClass("BodyGyro")
            if bodyGyro then
                bodyGyro:Destroy()
            end
        end
    end
})
  -- Função para teleportar o personagem 5 blocos acima de cada moeda
function teleporteParaMoedas()
    local player = game.Players.LocalPlayer
    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        local character = player.Character
        local humanoidRootPart = character.HumanoidRootPart
        local coinSpawnsFolder = game.Workspace.Lobby.CoinSpawns
        
        if coinSpawnsFolder then
            for _, spawn in ipairs(coinSpawnsFolder:GetChildren()) do
                local coin = spawn:FindFirstChild("Coin")
                if coin and coin:FindFirstChild("Appa") then
                    local appa = coin.Appa
                    -- Teleporta o personagem 5 blocos acima da moeda
                    humanoidRootPart.CFrame = appa.CFrame * CFrame.new(0, 7, 0)
                    wait(3) -- Pequena pausa para garantir que o teleporte ocorra corretamente
                    if not _G.coletafrutas then return end -- Para o loop caso o toggle seja desativado
                end
            end
        end
    end
end

-- Toggle para ativar/desativar a coleta de moedas
PlayerTab:AddToggle({
    Name = "COLLECT FRUIT",
    Default = false,
    Callback = function(Value)
        _G.coletafrutas = Value
        if Value then
            while _G.coletafrutas do
                teleporteParaMoedas()
                wait(1) -- Intervalo entre as coletas
            end
        end
    end
})

-- Inicia o loop de coleta se o toggle estiver ativado
if _G.coletafrutas then
    while _G.coletafrutas do
        teleporteParaMoedas()
        wait(1) -- Intervalo entre as coletas
    end
end






local function setSpeed(value)
    local player = game.Players.LocalPlayer
    local character = player.Character
    if character and character:FindFirstChild("Humanoid") then
        local humanoid = character:FindFirstChild("Humanoid")
        humanoid.WalkSpeed = tonumber(value)
    end
end
-- Função para equipar o equipamento Cutlass
local function equipCutlass(cutlass)
    if cutlass and cutlass:FindFirstChild("TouchInterest") then
        -- Simula um toque no equipamento
        local playerPart = game.Players.LocalPlayer.Character.PrimaryPart
        if playerPart then
            firetouchinterest(playerPart, cutlass, 0)
            firetouchinterest(playerPart, cutlass, 1)
        end
    end
end

-- Percorre todas as ilhas e tenta equipar o Cutlass em cada uma delas
local function equipCutlassInAllIslands()
    local islands = workspace.Map.Classic.Islands:GetChildren()

    for _, island in ipairs(islands) do
        local cutlass = island:FindFirstChild("Mountain") and island.Mountain:FindFirstChild("Cutlass")
        if cutlass then
            equipCutlass(cutlass)
        end
    end
end

      
PlayerTab:AddLabel("                                                    TOOL")


-- Adicionar o botão no PlayerTab
PlayerTab:AddButton({
    Name = "SWORD",
    Callback = function()
        -- Executar a função inicial para equipar o Cutlass nas ilhas já existentes
        equipCutlassInAllIslands()
    end
})

-- Função para encontrar o UFO nas ilhas ou fora delas e teletransportar o jogador para o VehicleSeat
local function teleportToVehicleSeat()
    local ufo

    -- Percorre todas as ilhas em busca do UFO
    for _, island in ipairs(workspace.Map.Classic.Islands:GetChildren()) do
        if island:FindFirstChild("Pad") and island.Pad:FindFirstChild("UFO") then
            ufo = island.Pad.UFO
            break
        end
    end

    -- Se não encontrar nas ilhas, verifica fora delas
    if not ufo then
        ufo = workspace:FindFirstChild("UFO")
    end

    -- Tenta encontrar o VehicleSeat dentro do UFO encontrado
    if ufo then
        local vehicleSeat = ufo:FindFirstChild("VehicleSeat") or (ufo:GetChildren()[6] and ufo:GetChildren()[6]:FindFirstChild("VehicleSeat"))
        if vehicleSeat then
            local player = game.Players.LocalPlayer
            if player and player.Character and player.Character.PrimaryPart then
                local character = player.Character
                local primaryPart = character.PrimaryPart

                -- Posiciona o personagem na mesma posição e orientação que o VehicleSeat
                primaryPart.CFrame = vehicleSeat.CFrame
            end
        end
    end
end

-- Adicionar o botão no PlayerTab
PlayerTab:AddButton({
    Name = "UFO",
    Callback = function()
        teleportToVehicleSeat()
    end
})

-- Função para interagir com o assento do Turret
local function interactWithTurretSeat(seat)
    if seat and seat:IsA("VehicleSeat") then
        -- Simula a interação com o assento
        local playerPart = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character.PrimaryPart
        if playerPart then
            firetouchinterest(playerPart, seat, 0)
            firetouchinterest(playerPart, seat, 1)
        end
    end
end

-- Função para verificar e interagir com todos os assentos do Turret nas ilhas
local function interactWithAllTurrets()
    local islands = workspace.Map.Classic.Islands:GetChildren()

    for _, island in ipairs(islands) do
        local turret = island:FindFirstChild("Top") and island.Top:FindFirstChild("Turret")
        if turret then
            local seat = turret:FindFirstChild("Head") and turret.Head:FindFirstChild("OperatorSeat")
            if seat then
                interactWithTurretSeat(seat)
            end
        end
    end
end

-- Adicionar o botão no PlayerTab
PlayerTab:AddButton({
    Name = "TOWER",
    Callback = function()
        interactWithAllTurrets()
    end
})

-- Função para encontrar e teletransportar para o Portal em qualquer ilha
local function teleportToPortal()
    local player = game.Players.LocalPlayer
    local islands = workspace:FindFirstChild("Map")
        and workspace.Map:FindFirstChild("Classic")
        and workspace.Map.Classic:FindFirstChild("Islands")

    if islands then
        for _, island in pairs(islands:GetChildren()) do
            local portal = island:FindFirstChild("Portal")
                and island.Portal:FindFirstChild("Content")
                and island.Portal.Content:FindFirstChild("Portal")

            if portal and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                player.Character.HumanoidRootPart.CFrame = portal.CFrame
                break
            end
        end
    end
end
-- Adicionar o botão no PlayerTab
PlayerTab:AddButton({
    Name = "PORTAL",
    Callback = function()
        teleportToPortal()
    end
})local args = {
    [1] = "HasChest"
}

function disableAnimations(object)
    for _, descendant in pairs(object:GetDescendants()) do
        if descendant:IsA("Tween") or descendant:IsA("Animation") then
            descendant:Destroy()
        elseif descendant:IsA("Script") or descendant:IsA("LocalScript") then
            descendant.Disabled = true
        end
    end
end

function AUTO()
    while _G.AUTOBAU do
        disableAnimations(workspace.Lobby.Chest.GoldChest)
        game:GetService("ReplicatedStorage").ReplicationManagers.ChestRF:InvokeServer(unpack(args))
        wait(0.01)
    end
end
PlayerTab:AddLabel("                                                  OPEN")

PlayerTab:AddToggle({
    Name = "BAÚ",
    Default = false,
    Callback = function(Value)
        _G.AUTOBAU = Value
        if _G.AUTOBAU then
            AUTO()
        end
    end    
})
                   
  -- Cria a aba e o toggle no OrionLib
local PLAYERTab = Window:MakeTab({
    Name = "PLAYER",
    Icon = "rbxassetid://14961970030", -- Substitua pelo ID correto do ícone
    PremiumOnly = false
})
  
PLAYERTab:AddLabel("                                          FUNÇÕES PLAYER")
  



 local isEspEnabled = false
local player = game.Players.LocalPlayer
local espInstances = {}

-- Função para criar ESP
local function createEsp(targetPlayer)
    local head = targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head")
    if head and not head:FindFirstChild("ESP") then
        local BillboardGui = Instance.new("BillboardGui", head)
        BillboardGui.Name = "ESP"
        BillboardGui.AlwaysOnTop = true
        BillboardGui.LightInfluence = 1
        BillboardGui.Size = UDim2.new(0, 200, 0, 50)
        BillboardGui.StudsOffset = Vector3.new(0, 3, 0)

        local TextLabel = Instance.new("TextLabel", BillboardGui)
        TextLabel.BackgroundTransparency = 1
        TextLabel.Size = UDim2.new(1, 0, 1, 0)
        TextLabel.Font = Enum.Font.GothamBold
        TextLabel.TextStrokeTransparency = 0.5
        TextLabel.TextSize = 14
        TextLabel.TextWrapped = true
        TextLabel.TextXAlignment = Enum.TextXAlignment.Center
        TextLabel.TextYAlignment = Enum.TextYAlignment.Center
        TextLabel.TextColor3 = (targetPlayer.Team == player.Team) and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(255, 0, 0)

        -- Função para atualizar o texto
        local function updateText()
            if head then
                local distance = (head.Position - game.Workspace.CurrentCamera.CFrame.Position).Magnitude
                TextLabel.Text = string.format("%s\n%.0f studs", targetPlayer.Name, distance)
            end
        end

        game:GetService("RunService").RenderStepped:Connect(updateText)
        table.insert(espInstances, BillboardGui)
    end
end

-- Função para remover ESP
local function removeEsp(targetPlayer)
    local head = targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head")
    if head then
        local espGui = head:FindFirstChild("ESP")
        if espGui then
            espGui:Destroy()
        end
    end
end

-- Função para atualizar o ESP
local function updateEsp()
    for _, v in ipairs(game.Players:GetPlayers()) do
        if v ~= player then
            if isEspEnabled then
                createEsp(v)
            else
                removeEsp(v)
            end
        end
    end
end


-- Adicionar Toggle para ativar/desativar o ESP
PLAYERTab:AddToggle({
    Name = "ESP PLAYER",
    Default = false,
    Callback = function(value)
        on = value -- Atualiza o status do ESP com o valor do botão de alternância
        isEspEnabled = value -- Atualiza o status do ESP com o valor do botão de alternância
        updateEsp() -- Atualiza o ESP com base no novo valor

                      end
})
-- Evento para remover o ESP ao sair do jogo
game.Players.PlayerRemoving:Connect(function(player)
    removeEsp(player)
end)

-- Evento para atualizar o ESP quando um novo jogador entrar
game.Players.PlayerAdded:Connect(function(newPlayer)
    if isEspEnabled then
        createEsp(newPlayer)
    end
end)

-- Função de loop para atualizar o ESP frequentemente
local function espLoop()
    while true do
        if isEspEnabled then
            updateEsp()
        end
        wait(1) -- Aguarde 1 segundo antes de atualizar novamente (ajuste conforme necessário)
    end
end

-- Iniciar o loop em uma nova thread
spawn(espLoop)

-- Atualizar ESP para todos os jogadores existentes quando o script é executado
if isEspEnabled then
    updateEsp()
end

-- Limpar todos os ESPs quando o script é reexecutado
for _, gui in pairs(espInstances) do
    if gui and gui.Parent then
        gui:Destroy()
    end
end
espInstances = {}


local noclipEnabled = false

PLAYERTab:AddToggle({
    Name = "NOCLIP",
    Default = false,
    Callback = function(value)
        noclipEnabled = value
        local player = game.Players.LocalPlayer
        local character = player.Character

        if character then
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.CanCollide = not noclipEnabled
                end
            end

            -- Opcional: Ajustar a saúde máxima e atual do jogador
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.MaxHealth = noclipEnabled and math.huge or 100
                humanoid.Health = noclipEnabled and math.huge or 100
            end
        end
    end
})

game:GetService("RunService").Stepped:Connect(function()
    if noclipEnabled then
        local player = game.Players.LocalPlayer
        local character = player.Character

        if character then
            for _, part in pairs(character:GetChildren()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end
end)

local InfiniteJumpEnabled = false  -- Adicionamos uma variável para rastrear o estado do pulo infinito

PLAYERTab:AddToggle({
    Name = "JUMP",
    Default = false,
    Callback = function(value)
        _G.infinitojump = value
        InfiniteJumpEnabled = value  -- Atualizamos o estado do pulo infinito ao ativar/desativar o toggle
        while _G.infinitojump do
            game:GetService("UserInputService").JumpRequest:Connect(function()
                if InfiniteJumpEnabled then
                    game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState("Jumping")
                end
            end)
            wait()
        end
    end
})

  
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local speedEnabled = false
local lastSelectedSpeed = "16"

-- Função para definir a velocidade do jogador
local function setSpeed(speedValue)
    if humanoid then
        humanoid.WalkSpeed = tonumber(speedValue)
    end
end

-- Função para atualizar a velocidade quando o toggle é alterado
local function onSpeedToggle(value)
    speedEnabled = value
    if value then
        setSpeed(lastSelectedSpeed)
    else
        setSpeed("16")  -- Substitua "16" pela velocidade padrão quando o toggle é desativado
    end
end

-- Função para lidar com a morte do jogador
local function onCharacterDied()
    if speedEnabled then
        -- Desativa a velocidade quando o jogador morre
        setSpeed("16")
    end
end

-- Função para lidar com o renascimento do jogador
local function onCharacterAdded(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    
    -- Reativa a velocidade se o toggle estiver ativado
    if speedEnabled then
        setSpeed(lastSelectedSpeed)
    end

    -- Conecta o evento de morte ao novo personagem
    humanoid.Died:Connect(onCharacterDied)
end

-- Função para manter a velocidade consistente
local function maintainSpeed()
    if speedEnabled then
        setSpeed(lastSelectedSpeed)
    end
end

-- Adiciona o toggle para controlar a velocidade
local speedToggle = PLAYERTab:AddToggle({
    Name = "SPEED",
    Default = false,
    Callback = onSpeedToggle
})

-- Adiciona o dropdown para selecionar a velocidade
local speedDropdown = PLAYERTab:AddDropdown({
    Name = "SELECT SPEED",
    Default = "16",
    Options = {"0", "5", "10", "16", "22", "30", "35", "40", "50", "55", "65", "70", "80", "90", "95", "100", "125", "150", "200", "250", "300", "325", "350", "375", "390", "400"},
    Callback = function(value)
        lastSelectedSpeed = value
        if speedEnabled then
            setSpeed(value)
        end
    end
})

-- Conecta os eventos de morte e renascimento
player.CharacterAdded:Connect(onCharacterAdded)
if character then
    humanoid.Died:Connect(onCharacterDied)
end

-- Configura o evento para garantir que a velocidade seja mantida
local function onHeartbeat()
    maintainSpeed()
end

-- Conecta a função de manutenção de velocidade ao evento Heartbeat
game:GetService("RunService").Heartbeat:Connect(onHeartbeat)
-- Conecta o evento de pular ao humanoide
local function onJumpRequest()
    if speedEnabled then
        setSpeed(lastSelectedSpeed)
    end
end

-- Conecta o evento de equipar itens
local function onEquipped()
    if speedEnabled then
        setSpeed(lastSelectedSpeed)
    end
end

-- Configura os eventos de pular e equipar itens
humanoid.Jumping:Connect(onJumpRequest)
local noclipEnabled = false


local MULTIPLAYERTab = Window:MakeTab({
    Name = " MULTIPLAYER",
    Icon = "rbxassetid://85826994371981", -- Substitua pelo ID correto do ícone
    PremiumOnly = false
})

local Plr = {}
local playerDropdown
local PlayerSelected = ""
local ToggleState = false
local localPlayer = game.Players.LocalPlayer

local function updatePlayerList()
    -- Limpa a lista anterior
    Plr = {}
    -- Popula a lista com os jogadores atuais
    for _, v in pairs(game:GetService("Players"):GetPlayers()) do
        if v.Name ~= localPlayer.Name then
            table.insert(Plr, v.Name)
        end
    end
    -- Mantém o jogador selecionado anterior se ainda estiver na lista, senão seleciona o primeiro jogador na nova lista
    if not table.find(Plr, PlayerSelected) then
        PlayerSelected = Plr[1] or ""
    end

    -- Atualiza o dropdown com a nova lista de jogadores
    if playerDropdown then
        playerDropdown:Refresh(Plr, true)
    end
end

-- Criação inicial do Dropdown com a lista de jogadores
playerDropdown = MULTIPLAYERTab:AddDropdown({
    Name = "SELECT PLAYER",
    Default = "1",
    Options = Plr,
    Callback = function(value)
        PlayerSelected = value
    end
})

-- Atualiza a lista de jogadores ao criar o dropdown
updatePlayerList()

-- Toggle para Alternar entre Espectar e Visualizar
MULTIPLAYERTab:AddToggle({
    Name = "SPECTATE",
    Default = false,
    Callback = function(value)
        ToggleState = value
        if ToggleState then
            -- Ativa a observação do jogador
            while ToggleState do
                wait()
                if PlayerSelected and game.Players[PlayerSelected] and game.Players[PlayerSelected].Character then
                    local targetCharacter = game.Players[PlayerSelected].Character
                    local humanoidRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
                    if humanoidRootPart then
                        -- Ajusta a câmera para seguir o jogador
                        local camera = game.Workspace.CurrentCamera
                        camera.CameraSubject = humanoidRootPart
                        -- Atualiza a posição da câmera para seguir o jogador
                        camera.CFrame = CFrame.new(
                            camera.CFrame.Position,
                            humanoidRootPart.Position
                        )
                    end
                end
            end
        else
            -- Retorna a câmera para o controle normal do jogador
            local camera = game.Workspace.CurrentCamera
            local playerCharacter = localPlayer.Character
            if playerCharacter and playerCharacter:FindFirstChild("HumanoidRootPart") then
                -- Aguardar um curto intervalo para garantir que o jogador esteja totalmente carregado
                wait(0.1)
                camera.CameraSubject = playerCharacter.HumanoidRootPart
                -- Reseta a posição da câmera para o jogador local
                camera.CFrame = CFrame.new(
                    playerCharacter.HumanoidRootPart.Position + Vector3.new(0, 5, -10),
                    playerCharacter.HumanoidRootPart.Position
                )
            end
        end
    end
})

-- Eventos para atualizar a lista de jogadores automaticamente
game.Players.PlayerAdded:Connect(updatePlayerList)
game.Players.PlayerRemoving:Connect(updatePlayerList)


-- Cria a aba e o toggle no OrionLib
local TeleportTab = Window:MakeTab({
    Name = "TELEPORT",
    Icon = "rbxassetid://18702220466", -- Substitua pelo ID correto do ícone
    PremiumOnly = false
})

-- Função para teletransportar o jogador para o local especificado
local function teleportToLobby()
    local player = game.Players.LocalPlayer
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
        player.Character.HumanoidRootPart.CFrame = CFrame.new(244.87147521972656, 57.601322174072266, -6.117152690887451)
    end
end

-- Adicionar o botão no PlayerTab
TeleportTab:AddButton({
    Name = "LOBBY",
    Callback = function()
        teleportToLobby()
    end
})
TeleportTab:AddLabel("                                          PLAYER TELEPORT")
  

local PlayerTP
local Plr = {}
local playerDropdown

local function updatePlayerList()
    -- Limpa a lista anterior
    Plr = {}
    -- Popula a lista com os jogadores atuais
    for _, v in pairs(game:GetService("Players"):GetPlayers()) do
        if v.Name ~= game.Players.LocalPlayer.Name then
            table.insert(Plr, v.Name)
        end
    end
    -- Atualiza o jogador selecionado para o primeiro na nova lista
    PlayerTP = Plr[1] or ""
    
    -- Atualiza o dropdown com a nova lista de jogadores
    if playerDropdown then
        playerDropdown:Refresh(Plr, true)
    end
end

-- Criação inicial do Dropdown com a lista de jogadores
playerDropdown = TeleportTab:AddDropdown({
    Name = "SELECT PLAYER",
    Default = "1",
    Options = Plr,
    Callback = function(value)
        PlayerTP = value
    end
})

-- Atualiza a lista de jogadores ao criar o dropdown
updatePlayerList()

TeleportTab:AddButton({
    Name = "CLICK TELEPORT",
    Callback = function()
        if PlayerTP and game.Players[PlayerTP] and game.Players[PlayerTP].Character and game.Players[PlayerTP].Character:FindFirstChild("HumanoidRootPart") then
            game.Players.LocalPlayer.Character:MoveTo(game.Players[PlayerTP].Character.HumanoidRootPart.Position)
        end
    end
})

local TPPlayer = false
TeleportTab:AddToggle({
    Name = "TELEPORT",
    Default = false,
    Callback = function(value)
        TPPlayer = value
        while TPPlayer do
            wait()
            if PlayerTP and game.Players[PlayerTP] and game.Players[PlayerTP].Character and game.Players[PlayerTP].Character:FindFirstChild("HumanoidRootPart") then
                game.Players.LocalPlayer.Character:MoveTo(game.Players[PlayerTP].Character.HumanoidRootPart.Position)
            end
        end
    end
})

-- Eventos para atualizar a lista de jogadores automaticamente
game.Players.PlayerAdded:Connect(updatePlayerList)
game.Players.PlayerRemoving:Connect(updatePlayerList)

   
-- Cria a aba e o toggle no OrionLib
local CONFIGTab = Window:MakeTab({
    Name = "CONFIG",
    Icon = "rbxassetid://18702777518", -- Substitua pelo ID correto do ícone
    PremiumOnly = false
})

CONFIGTab:AddLabel("                                                   DISABLE")
local waterListener
local monitoringEnabled = false

local function safelyRemoveItem(parent, itemName)
    local item = parent:FindFirstChild(itemName)
    if item then
        pcall(function()
            item:Destroy()
        end)
    end
end

local function removeWater()
    local map = workspace:FindFirstChild("Map")
    if map then
        local classic = map:FindFirstChild("Classic")
        if classic then
            safelyRemoveItem(classic, "Water")
        end
    end
end

local function setupWaterRemover()
    local map = workspace:WaitForChild("Map")
    local classic = map:WaitForChild("Classic")

    -- Remove qualquer água existente
    safelyRemoveItem(classic, "Water")

    -- Configura listener para remover água quando aparecer
    if waterListener then
        waterListener:Disconnect()
    end

    waterListener = classic.ChildAdded:Connect(function(child)
        if child.Name == "Water" then
            safelyRemoveItem(classic, "Water")
        end
    end)
end

local function monitorWater()
    while monitoringEnabled do
        wait(1)  -- Ajuste o intervalo conforme necessário
        removeWater()  -- Verifica e remove qualquer água
    end
end

-- Botão para remover água e iniciar monitoramento
CONFIGTab:AddButton({
    Name = "WATER",
    Callback = function()
        if not monitoringEnabled then
            monitoringEnabled = true
            setupWaterRemover()  -- Inicia o monitoramento de novos objetos "Water"
            coroutine.wrap(monitorWater)()  -- Inicia o monitoramento contínuo
        end
        removeWater()  -- Remove qualquer água existente no momento
    end
})




CONFIGTab:AddLabel("                                                  CODES")
-- Define os códigos a serem redimidos
local codes = {"200KLIKES", "250KLIKES"}

-- Função para redimir os códigos
local function redeemCodes()
    for _, code in ipairs(codes) do
        local args = {
            [1] = "Redeem",
            [2] = code
        }

        game:GetService("ReplicatedStorage").ReplicationManagers.CodesRF:InvokeServer(unpack(args))
    end
end

-- Cria o botão na aba de controle
CONFIGTab:AddButton({
    Name = "REDEEM",
    Callback = redeemCodes
})

CONFIGTab:AddLabel("                                                  SERVER")


-- Função para reiniciar o jogo
local function rejoinGame()
    -- Primeiro, desconecta do servidor atual

game:GetService("Players").LocalPlayer:Kick("《SyniX HUB》 Rejoining the game...")    -- Depois de um pequeno atraso, reconecta ao servidor com o mesmo mapa
    wait(0.1)  -- Tempo de espera para garantir que a desconexão ocorreu

    -- Obtém o ID do mapa atual e tenta se conectar ao servidor
    local TeleportService = game:GetService("TeleportService")
    local player = game.Players.LocalPlayer
    TeleportService:Teleport(game.PlaceId, player)
end

-- Adiciona o botão à aba CONFIG
CONFIGTab:AddButton({
    Name = "REJOIN",
    Callback = function()
        rejoinGame()  -- Chama a função de rejoin quando o botão é clicado
    end
})
  

CONFIGTab:AddButton({
    Name = "FEW PLAYERS",
    Callback = function()
        local AllIDs = {}
        local foundAnything = ""
        local actualHour = os.date("!*t").hour
        local S_T = game:GetService("TeleportService")
        local S_H = game:GetService("HttpService")
        local placeId = game.PlaceId  -- Obtém automaticamente o ID do jogo atual

        -- Tenta ler o arquivo de IDs de servidores já visitados
        local File = pcall(function()
            AllIDs = S_H:JSONDecode(readfile("server-hop-temp.json"))
        end)
        if not File then
            table.insert(AllIDs, actualHour)
            pcall(function()
                writefile("server-hop-temp.json", S_H:JSONEncode(AllIDs))
            end)
        end

        local function PlayAnimation()
   -- Gui to Lua
-- Version: 3.2

-- Instances:

local notfic = Instance.new("ScreenGui")
local backNOT = Instance.new("Frame")
local UICorner = Instance.new("UICorner")
local UIAspectRatioConstraint = Instance.new("UIAspectRatioConstraint")
local div = Instance.new("Frame")
local div1 = Instance.new("Frame")
local SynixText = Instance.new("TextLabel")
local UIAspectRatioConstraint_2 = Instance.new("UIAspectRatioConstraint")
local ImageLabel = Instance.new("ImageLabel")
local UIAspectRatioConstraint_3 = Instance.new("UIAspectRatioConstraint")
local UIAspectRatioConstraint_4 = Instance.new("UIAspectRatioConstraint")
local textarea = Instance.new("Frame")
local UIAspectRatioConstraint_5 = Instance.new("UIAspectRatioConstraint")
local textanot = Instance.new("TextLabel")
local UIAspectRatioConstraint_6 = Instance.new("UIAspectRatioConstraint")

-- Properties:

notfic.Name = "notfic"
notfic.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
notfic.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

backNOT.Name = "backNOT"
backNOT.Parent = notfic
backNOT.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
backNOT.BackgroundTransparency = 0.400
backNOT.BorderColor3 = Color3.fromRGB(0, 0, 0)
backNOT.BorderSizePixel = 0
backNOT.Position = UDim2.new(0.776361048, 0, 0.709379315, 0)
backNOT.Size = UDim2.new(0.384245038, 0, 0.183602542, 0)

UICorner.Parent = backNOT

UIAspectRatioConstraint.Parent = backNOT
UIAspectRatioConstraint.AspectRatio = 3.560

div.Name = "div"
div.Parent = backNOT
div.BackgroundColor3 = Color3.fromRGB(167, 167, 167)
div.BackgroundTransparency = 1
div.BorderColor3 = Color3.fromRGB(0, 0, 0)
div.BorderSizePixel = 0
div.Position = UDim2.new(-0.00190504093, 0, 0.401610732, 0)
div.Size = UDim2.new(0.703590274, 0, 0.0135650374, 0)

div1.Name = "div1"
div1.Parent = backNOT
div1.BackgroundColor3 = Color3.fromRGB(167, 167, 167)
div1.BackgroundTransparency = 0.500
div1.BorderColor3 = Color3.fromRGB(0, 0, 0)
div1.BorderSizePixel = 0
div1.Position = UDim2.new(-0.00190504093, 0, 0.401610732, 0)
div1.Size = UDim2.new(0.703590274, 0, 0.0135650374, 0)


SynixText.Name = "SynixText"
SynixText.Parent = div
SynixText.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
SynixText.BackgroundTransparency = 1.000
SynixText.BorderColor3 = Color3.fromRGB(0, 0, 0)
SynixText.BorderSizePixel = 0
SynixText.Position = UDim2.new(0.174563825, 0, -25.2587624, 0)
SynixText.Size = UDim2.new(0.695285857, 0, 19.9284687, 0)
SynixText.Font = Enum.Font.GothamBlack
SynixText.Text = "SyniX - Notific"
SynixText.TextColor3 = Color3.fromRGB(255, 255, 255)
SynixText.TextScaled = true
SynixText.TextSize = 11.000
SynixText.TextStrokeColor3 = Color3.fromRGB(255, 255, 255)
SynixText.TextWrapped = true

UIAspectRatioConstraint_2.Parent = SynixText
UIAspectRatioConstraint_2.AspectRatio = 5.583

ImageLabel.Parent = div
ImageLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ImageLabel.BackgroundTransparency = 1.000
ImageLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
ImageLabel.BorderSizePixel = 0
ImageLabel.Position = UDim2.new(0.0560515448, 0, -26.2637463, 0)
ImageLabel.Size = UDim2.new(0.127630442, 0, 21.7752609, 0)
ImageLabel.Image = "rbxassetid://14862323455"

UIAspectRatioConstraint_3.Parent = ImageLabel

UIAspectRatioConstraint_4.Parent = div
UIAspectRatioConstraint_4.AspectRatio = 184.650

textarea.Name = "textarea"
textarea.Parent = backNOT
textarea.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
textarea.BackgroundTransparency = 1.000
textarea.BorderColor3 = Color3.fromRGB(0, 0, 0)
textarea.BorderSizePixel = 0
textarea.Position = UDim2.new(0, 0, 0.415175945, 0)
textarea.Size = UDim2.new(0.701685667, 0, 0.582388222, 0)

UIAspectRatioConstraint_5.Parent = textarea
UIAspectRatioConstraint_5.AspectRatio = 4.289

textanot.Name = "textanot"
textanot.Parent = textarea
textanot.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
textanot.BackgroundTransparency = 1.000
textanot.BorderColor3 = Color3.fromRGB(0, 0, 0)
textanot.BorderSizePixel = 0
textanot.Position = UDim2.new(0.0892357156, 0, 0.159190118, 0)
textanot.Size = UDim2.new(0.762829661, 0, 1.50985551, 0)
textanot.Font = Enum.Font.GothamBold  -- Fonte em negrito
textanot.LineHeight = 0.850
textanot.Text = "Searching for Server..."
textanot.TextColor3 = Color3.fromRGB(255, 255, 255)
textanot.TextScaled = true
textanot.TextSize = 5.000
textanot.TextWrapped = true
UIAspectRatioConstraint_6.Parent = textanot
UIAspectRatioConstraint_6.AspectRatio = 5.080
UIAspectRatioConstraint_6.DominantAxis = Enum.DominantAxis.Height

local duration = 5 -- Duração da notificação em segundos
local endTime = tick() + duration

while tick() < endTime do
    local remainingTime = endTime - tick()
    local scaleFactor = remainingTime / duration
    div1.Size = UDim2.new(scaleFactor, 0, 0.0135650374, 0)
    wait(0.1) -- Atualize o tamanho a cada 0.1 segundo (você pode ajustar esse valor conforme necessário)
end

-- Agora que o tempo acabou, você pode esconder e remover a notificação
div1.Visible = false
backNOT:Destroy() -- Isso remove o frame completamente
        end

        local function TPReturner()
            local Site
            if foundAnything == "" then
                Site = S_H:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. placeId .. '/servers/Public?sortOrder=Asc&limit=100'))
            else
                Site = S_H:JSONDecode(game:HttpGet('https://games.roblox.com/v1/games/' .. placeId .. '/servers/Public?sortOrder=Asc&limit=100&cursor=' .. foundAnything))
            end

            if Site.nextPageCursor then
                foundAnything = Site.nextPageCursor
            end

            local num = 0
            for _, v in pairs(Site.data) do
                local Possible = true
                local ID = tostring(v.id)
                local playerCount = tonumber(v.playing)

                -- Verifica se o servidor tem entre 1 e 2 jogadores
                if playerCount >= 1 and playerCount <= 7 then
                    for _, Existing in pairs(AllIDs) do
                        if num ~= 0 and ID == tostring(Existing) then
                            Possible = false
                            break
                        elseif tonumber(actualHour) ~= tonumber(Existing) then
                            pcall(function()
                                delfile("server-hop-temp.json")
                                AllIDs = {actualHour}
                            end)
                        end
                        num = num + 1
                    end
                    if Possible then
                        table.insert(AllIDs, ID)
                        pcall(function()
                            writefile("server-hop-temp.json", S_H:JSONEncode(AllIDs))

                            -- Execute a animação
                            coroutine.wrap(function()
                                PlayAnimation()
                            end)()

                            -- Aguarde um intervalo aleatório antes de iniciar o teleporte
                            local delays = {4.3, 3.9, 3.6}
                            local delay = delays[math.random(1, #delays)] -- Escolhe aleatoriamente um dos intervalos
                            wait(delay) -- Ajuste conforme necessário para garantir que o teleporte ocorra antes da animação terminar

                            -- Após o intervalo, realize o teleporte
                            S_T:TeleportToPlaceInstance(placeId, ID, game.Players.LocalPlayer)
                        end)
                        wait(4) -- Pequena espera antes de tentar novamente
                        break
                    end
                end
            end
        end

        -- Inicia o processo de teleporte ao clicar no botão
        pcall(function()
            TPReturner()
            while foundAnything ~= "" do
                TPReturner()
            end
        end)
    end
})
                                                 
                                                   CONFIGTab:AddLabel("                                                   SOON")
end
